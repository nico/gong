Lexer
=====

Eventually: code completion markers
fixits, ranges
flag to dump stats

mark unknown tokens in the rune / string error cases as literals, so that semi
insertion is done. Makes error recovery nicer. (`var a = ''\nvar b` doesn't
recover well atm)

lookahead

literal lexing and diags (078 vs 078.0, 'aa', etc. `ack FIXME test/Lex`)

use lexer to train a n-gram token model, write a markov go generator using that
data


Parser
=====

Allow parens around receiver types,
https://code.google.com/p/go/source/detail?r=c7fe6d0e90eb

for f in $(find ~/src/go/src/pkg/ -name '*.go'); do echo $f; if ! ../../Release+Asserts/bin/gong $f; then break; fi; done

check IsExpression() everywhere ParseExpression() is called

ExprResult/StmtResult for result passing

diag only once on 
  a := (a[1)

Only one diag when ending a file without a closing ) (imports) / } (blocks)

Actions interface

measureTokenLength

go doesn't need predeclarations for methods, figure out how to do that
=> similar to objc, check what clang does.

Have nice fixit for toplevel `a := b`

Handle https://groups.google.com/forum/#!topic/golang-nuts/Bv4GDkPRMxA well

missing closing braces after interface, struct, blocks, selects, switchs
missing closing parens after impor/var/const/type spec


introduce a consistent naming scheme for functions that assert the current
token type vs those that don't
    handle tok::unknown
  MaybeParse...() in clang is for stuff based on langopts
  TryParseFoo / TryFoo
  ExpectFoo
  MustParseFoo
  DoParseFoo
  DiagParseFoo
  ErrParseFoo
  SoftParseFoo
  CanParseFoo
  CouldParseFoo
  ConsumeFoo
  EatFoo
  CheckParseFoo
    ...but in all cases, only the head is asserted

  parser.go does tryFoo / parseFoo. acorn.js mostly does parseFoo.

share {} parsing code for interface{}, struct{}, and possibly blocks,
selectstmts, and switchstmts

maybe share the optional SimpleStmt parsing code in ifstmt, forstmt, switchstmt

make it so that eg |type t ['4'.(int]int| gets only one diag. clang does this
with this code in ParseParenExpr() (at the very end):

  if (Result.isInvalid()) {
    SkipUntil(tok::r_paren);
    return ExprError();
  }

  T.consumeClose();



nice diag with fixit (insert '()') for `func main {}`

nice diag with fixit (insert ',') for
  myfunc(
    4
  )

nice diag with fixit (insert "()") for |if a == type{} { ... }|

Add scopes:
function parameters
each if, for, and switch is in its own implicit block
each clause of a switch or select acts as an implicit block


Actions
=======

types/exprs in ()
(*TypeName) in MethodExprs
*foo() vs (*foo)()
<-foo() vs (<-foo)()
func()(foo) vs (func())(foo)


Frontend
========

-parse-noop and -parse-print-callbacks: (r109392)
lib/Frontend/FrontendActions.cpp
ParseOnlyAction
PrintParseAction
tools/driver/cc1_main.cpp
clang/Frontend/FrontendActions.h



Long term
=========

http://llvm.org/docs/GarbageCollection.html
-> Can this work with the regular go collector?

libclang-style c api
python bindings for that c api
clang-complete clone on top of the python bindings
code formatter (lexer, parser, or ast based?)
tooling / refactoring stuff


Notes
=====

go is easier to lex:
- no escaped newlines
- no trigraphs
- no preprocessor
- way fewer string literal types

parse:
- no templates
- no vexing parse
- fewer precedence levels

+ annoying: parameterdecl. if identifier, need to look at next token.
                           if next is ',', identifier is part of IdentifierList
                           elif next is '...', identifier is IdentifierList
                           elif next is type, identifier is IdentifierList
                           else identifier is type
+ annoying: simplestmt vs expr in if. always need to parse simplestmt, and then
            potentially convert to expr. "for" is worse cause the simplestmt
            parsing needs to allow a rangeexpr in that case too.
+ annoying: switchstms. Have to parse a simplestmt first, but if that's not
            followed by a ';', the simplestmt was actually a TypeSwitchGuard,
            so parsesimplestmt needs to allow that too :-/

+ annoying: func(a, b, c) is a typelist while func(a, b, c int) is an identifier
            list with one type. (not terrible, but annoying. also annoying for
            ... in type lists.)

+ annoying: |if a == b {}| can be a compositelit or just |b| and a block. But
            made less annoying by the spec:

"""A parsing ambiguity arises when a composite literal using the TypeName form
of the LiteralType appears between the keyword and the opening brace of the
block of an "if", "for", or "switch" statement, because the braces surrounding
the expressions in the literal are confused with those introducing the block of
statements. To resolve the ambiguity in this rare case, the composite literal
must appear within parentheses.

if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }
"""


spec groups:
import, var, const, type


range expressions are weird. They're the only place where full expressions are
allowed at the lhs (actually, RecvStms are like this too). This is valid:

package main
func main() {
  arr := [...]int {1, 2, 3 }
  for arr[0] := range arr {
    println(arr[0])
  }
}

But this is not:

package main
func main() {
  arr := [...]int {1, 2, 3 }
  for arr[0] := 0; arr[0] < 2; arr[0]++ {
    println(arr[0])
  }
}

(Both programs are valid if you use '=' instead of ':=')

minimalaction deletion:
http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20100719/032534.html


clang diags:
DiagnosticsEngine::Diag() central function
ArgumentKind has std_string, declcontext, etc
has a SourceManager
error limits, ignores warnings, fatal errors, include stacks, macro stacks,
template stacks, some argumentkinds (identifierinfo and later) and corresponding
DiagBuilder operator<< overloads

DiagnosticBuilder adds stuff (arguments, source ranges) stuff to diags before
they're printed

Delegates to DiagnosticConsumer

DiagnosticsEngine uses DiagnosticIDs as id database, which in turn depends on
all the hardcoded .td files for clang stuff. (DiagnosticIDs::EmitDiag() gets a
DiagnosticEngine object.)

DiagnosticConsumers:
TextDiagnosticBuffer: Stores messages
TextDiagnosticPrinter: Prints messages

DiagnosticEngine dep on DiagnosticIDs might be movable behind an interface.
